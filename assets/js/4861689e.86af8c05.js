"use strict";(self.webpackChunkvector_search_workshop=self.webpackChunkvector_search_workshop||[]).push([[245],{3384:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var o=n(5893),r=n(1151);const s={},a="\ud83d\udc50 Update API routes",i={id:"vector-search/update-routes",title:"\ud83d\udc50 Update API routes",description:"We're now ready to implement changes to our API route in order to utilize Vector Search with our new embeddings.",source:"@site/docs/5-vector-search/6-update-routes.mdx",sourceDirName:"5-vector-search",slug:"/vector-search/update-routes",permalink:"/vector-search-workshop/docs/vector-search/update-routes",draft:!1,unlisted:!1,editUrl:"https://github.com/mongodb-developer/vector-search-workshop/blob/main/docs/5-vector-search/6-update-routes.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udc50 Create Vector Search indexes",permalink:"/vector-search-workshop/docs/vector-search/create-index"},next:{title:"\ud83c\udfaf Summary",permalink:"/vector-search-workshop/docs/summary"}},c={},d=[{value:"Add a Vector Search route",id:"add-a-vector-search-route",level:2},{value:"Update the <code>chat</code> route",id:"update-the-chat-route",level:2},{value:"Test it out",id:"test-it-out",level:2}];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"-update-api-routes",children:"\ud83d\udc50 Update API routes"}),"\n",(0,o.jsx)(t.p,{children:"We're now ready to implement changes to our API route in order to utilize Vector Search with our new embeddings."}),"\n",(0,o.jsxs)(t.p,{children:["The default API route for our chats can be found in ",(0,o.jsx)(t.code,{children:"api/chat/route.ts"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"add-a-vector-search-route",children:"Add a Vector Search route"}),"\n",(0,o.jsxs)(t.p,{children:["Before we modify that route, we'll implement a new route dedicated to handling Vector Search. Create a new file ",(0,o.jsx)(t.code,{children:"api/vectorSearch/route.ts"})," and add the following code:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:'import { OpenAIEmbeddings } from "@langchain/openai";\nimport mongoClientPromise from \'@/app/lib/mongodb\';\nimport { MongoDBAtlasVectorSearch } from "@langchain/mongodb";\n\nexport async function POST(req: Request) {\n    const client = await mongoClientPromise;\n    const dbName = "docs";\n    const collectionName = "embeddings";\n    const collection = client.db(dbName).collection(collectionName);\n\n    const dbConfig = {  \n        collection: collection,\n        indexName: "vector_index", // The name of the Atlas search index to use.\n        textKey: "text", // Field name for the raw text content. Defaults to "text".\n        embeddingKey: "embedding", // Field name for the vector embeddings. Defaults to "embedding".\n      };\n      const vectorStore = new MongoDBAtlasVectorSearch(\n        new OpenAIEmbeddings({\n          stripNewLines: true,\n        }), dbConfig);\n        \n      const question = await req.text();\n      const retriever = await vectorStore.asRetriever({\n        searchType: "mmr", // Defaults to "similarity\n        searchKwargs: {\n          fetchK: 20,\n          lambda: 0.1,\n        },\n      });\n    \n\n    const retrievedResults = await retriever.getRelevantDocuments(question)\n  \n    return Response.json(retrievedResults);\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["In this route, we'll connect to MongoDB, but differently than we did before. Notice that we are importing ",(0,o.jsx)(t.code,{children:"mongoClientPromise"})," from ",(0,o.jsx)(t.code,{children:"@/app/lib/mongodb"}),". This is a promise that resolves to a MongoDB client. We'll use this promise to gloabally cache our MongoDB client, so that we don't have to connect to MongoDB every time we want to make a request. This is a common pattern in serverless applications, and it's a good idea to do this in order to avoid connection limits."]}),"\n",(0,o.jsx)(t.p,{children:"We are also recieving the users prompt, or question, from the request body. Then we'll use the MongoDB Atlas Vector Search LangChain method to create vector embeddings for the users question."}),"\n",(0,o.jsx)(t.p,{children:"Remember, we have to also create vector embeddings for the user interaction so that we can then compare it with the other vector embeddings we have stored in MongoDB for our custom data."}),"\n",(0,o.jsx)(t.p,{children:"We tell it which collection, index, text key, and embedding key to use. Then we do the search. We're using something called maximal marginal relevance to find the related documents."}),"\n",(0,o.jsx)(t.p,{children:"We can specify the number of results to fetch and how many of those top results to return. This allows us to refine how accurate we want to be."}),"\n",(0,o.jsx)(t.p,{children:"Finally, we return the retriever output."}),"\n",(0,o.jsxs)(t.h2,{id:"update-the-chat-route",children:["Update the ",(0,o.jsx)(t.code,{children:"chat"})," route"]}),"\n",(0,o.jsxs)(t.p,{children:["Now that we have a route dedicated to Vector Search, we can update our ",(0,o.jsx)(t.code,{children:"chat"})," route to use it. Open ",(0,o.jsx)(t.code,{children:"api/chat/route.ts"})," and replace the code with the following:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:'import { StreamingTextResponse, LangChainStream, Message } from "ai";\nimport { ChatOpenAI } from "langchain/chat_models/openai";\nimport { AIMessage, HumanMessage } from "langchain/schema";\n\nexport const runtime = "edge";\n\nexport async function POST(req: Request) {\n  const { messages } = await req.json();\n  const currentMessageContent = messages[messages.length - 1].content;\n\n  const vectorSearch = await fetch("http://localhost:3000/api/vectorSearch", {\n    method: "POST",\n    headers: {\n      "Content-Type": "application/json",\n    },\n    body: currentMessageContent,\n  }).then((res) => res.json());\n\n  const TEMPLATE = `You are a very enthusiastic FancyWidget representative who loves to help people! Given the following sections from the FancyWidget documentation, answer the question using only that information, outputted in markdown format. If you are unsure and the answer is not explicitly written in the documentation, say "Sorry, I don\'t know how to help with that."\n  \n  Context sections:\n  ${JSON.stringify(vectorSearch)}\n\n  Question: """\n  ${currentMessageContent}\n  """\n  `;\n\n  messages[messages.length -1].content = TEMPLATE;\n\n  const { stream, handlers } = LangChainStream();\n\n  const llm = new ChatOpenAI({\n    modelName: "gpt-3.5-turbo",\n    streaming: true,\n  });\n\n  llm\n    .call(\n      (messages as Message[]).map((m) =>\n        m.role == "user"\n          ? new HumanMessage(m.content)\n          : new AIMessage(m.content)\n      ),\n      {},\n      [handlers]\n    )\n    .catch(console.error);\n\n  return new StreamingTextResponse(stream);\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"We're using the same code as before, but we're now using the vector search route to get the context sections. We'll then use those context sections to create a template for the AI to answer the question."}),"\n",(0,o.jsx)(t.h2,{id:"test-it-out",children:"Test it out"}),"\n",(0,o.jsx)(t.p,{children:"Be sure you've saved all of the files and restart the dev server."}),"\n",(0,o.jsx)(t.p,{children:"Now, when you ask a question about the FancyWidget documentation, you should get a response that is relevant to the question you asked."}),"\n",(0,o.jsx)(t.p,{children:'If you ask a question that is not in the documentation, you should get a response that says "Sorry, I don\'t know how to help with that."'}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["You can find a list of sample questions to ask in the ",(0,o.jsx)(t.code,{children:"_workshop_assets/questions.txt"})," file."]})})]})}function l(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>a});var o=n(7294);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);